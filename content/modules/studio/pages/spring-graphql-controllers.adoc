= Spring GraphQL Controllers

[][[intro-about]]
== About Spring for GraphQL API

GraphQL is a query language whose development started in 2012. It is open-source and supports query and data manipulation for APIs. GraphQL has been implemented in several programming languages, including Java, by different teams, and its Java implementation is named *_GraphQL Java_*.

*_Spring for GraphQL_* has been developed to support Spring-based applications that use GraphQL Java and  is the successor of the *_GraphQL Java Spring_* project from the GraphQL Java team. This product has found its place in the Amplicode project where it is routinely used to manage data access and modification.

See also:

 * https://docs.spring.io/spring-graphql/docs/current/reference/html/#overview[Spring for GraphQL Overview]

 * https://www.graphql-java.com/documentation/getting-started[GraphQL Java Documentation]

 * https://en.wikipedia.org/wiki/GraphQL[Wikipedia Article about GraphQL]

//TODO

[[empty-controller]]
== Creating an Empty Controller

//TODO

[[create-crud-controller]]
== Creating CRUD controller by Spring Data repository

//TODO

[[designer]]
== Designer:

[[palette-items]]
=== Palette items

//TODO

[[inspector-items]]
=== Inspector items

//TODO

[[schema-first]]
== Schema-first creation of controllers and DTOs

//TODO

[[scalars]]
== Supported types and scalars

By default, Spring for GraphQL supports scalar types mentioned in the GraphQL specification, namely:

Int - 32-bit signed.
Float - IEEE 754.
String - UTF-8.
Boolean - true/false.
ID - serialized representation - String

Besides, Spring for GraphQL offers an opportunity to add our own scalar types.

Spring for GraphQL is based on GraphQL Java, where the mapping between scalar types and Java types is defined as follows:

|===
|*Scalar Type*	|*Java Type*
|Int	|Integer
|Float	|Double
|String	|String
|Boolean	|Boolean
|ID	|String, Integer, Long, UUID, BigInteger
|===

To implement scalar types, Amplicode uses an approach requiring that each scalar type corresponds to one JS type and one Java type. This approach involves using scalar types from existing libraries: *_graphql-scalars_* for *_JavaScript_* and  *_Extended Scalars_* for *_Java_*. It is also true that:

 * Knowing a scalar type we can unambiguously define the validation rules and the representation rules for the type in UI.

 * It is possible to generate type-safe TypeScript and Java clients for a scalar type, since the correspondence is one-to-one.

The mapping between scalar types and Java types is given in the table below:

 * *_Scalar Type_* - Scalar type name in the GraphQL schema

 * *_Java Type_* - Java type used for this scalar type

 * *_JSON presentation_* - the description of how the value is stored

 * *_JSON Sample_* - value example.

|===
|*Scalar Type*	|*Java Type*	|*JSON presentation*	|*JSON Sample*
|*Standard types* |||
|Int	|Integer, int, Byte, byte, Short, short, char	|A signed 32‐bit integer	|5
|Float	|Double, double, Float, float	|A signed double-precision floating-point value	|5.5
|String	|String, UUID	|An UTF‐8 string	|"valueString"
|Boolean	|Boolean, boolean	|true or false	|true
|ID	|String, Integer, Long, UUID	|An UTF‐8 string	|"code"
|*Extended types* |||
|BigInteger	|BigInteger	|A value as string	|"120 000"
|Long	|Long, long	|A value as UTF‐8 string	|"120 000"
|BigDecimal	|BigDecimal	|value as string	|"123.505"
|Date	|LocalDate	|A date string, full-date format RFC3339	|"2007-12-03"
|Time	|OffsetTime	|A time string with offset, full-time format RFC3339	|"14:10:20+01:00"
|DateTime	|OffsetDateTime	|A date time string with offset, date-time format RFC3339	|"2016-01-01T14:10:20+01:00"
|Url	|URL	|URL format as specified in RFC3986	|"http://yandex.ru"
|Void	|Void	|null	|null
|LocalTime	|LocalTime	|A local time string (i.e., with no associated timezone) in 24-hr HH:mm[:ss[.SSS]] format	|"14:25 or 14:25:06 or 14:25:06.123"
|LocalDateTime	|LocalDateTime	|A local datetime string in full-date"T"partial-time format RFC3339	|"2007-12-03T14:25:06"
|Timestamp	|Date	|A value as string of number of milliseconds from start of UNIX epoch	|"1644399147756"
|===

https://datatracker.ietf.org/doc/html/rfc3339#section-5.6[RFC3339 date time formats]

While generating a GraphQL schema:

 * It is necessary to choose a scalar type according to the table above.

 * Types not listed in the table should be treated as objects. Meaning that if there is no corresponding scalar type for a Java type, a new GraphQL type is created in the GraphQL schema. Then we define the Java type structure (its fields) and add the fields to the generated GraphQL type.

 * Data arrays are represented as arrays in the schema. For example double[] is represented as Float[] in the schema.

[id]
== ID Type

An ID scalar in a GraphQL schema is an indicator of a simple autogenerated identifier.

In `graphql-java`, and ID scalar can correspond to one of the following Java types:

. `java.lang.String`
. `java.lang.Integer`
. `java.lang.Long`
. `java.util.UUID`
. `java.math.BigInteger`

To interact with a client the ID scalar should be serialized as a string.

Examples of the ID scalar representation in JSON by Java type are given in the table below:

|===
|Java type	|JSON presentation	|JSON Sample
|java.lang.String	|An UTF‐8 string	|"uniquecode"
|java.lang.Integer	|An UTF-8 string	|"1"
|java.util.UUID	|An UTF‐8 string	|"4e083530-0b9c-11e1-9b41-6bdaa41bff94"
|java.lang.Long	|An UTF-8 string	|"123456"
|java.math.BigInteger	|An UTF-8 string	|"2147483647"
|===

Examples of using ID scalars in the GraphQL schema:

+1.+ In a type declaration

[source, java]
type OwnerDTO {
  id: ID
  address: String
  city: String
  email: String
  firstName: String
  lastName: String
  telephone: String
}

In this case, the `id` field will be an identifier for `OwnerDTO`, since it has an `ID` type.

+2.+ In an input declaration

[source, java]
input OwnerDTOInput {
id: ID
address: String
city: String
email: String
firstName: String
lastName: String
telephone: String
}

In this case the `id` field will also be an identifier for `OwnerDTOInput`, since it has an `ID` type.

+3.+ In a mutation for deleting an object by id

[source, java]
"Mutation root"
type Mutation {
delete_Owner(id: ID!): Void
}

+4.+ In a query for loading an object by id

[source, java]
"Query root"
type Query {
owner(id: ID!): OwnerDTO
}

Technically, several ID fields can be declared for an object; in this case, the user has to select in the wizard which field to use as the ID.


[[define-id]]
== Defining the ID while generating the GraphQL schema

[[query-id]]
=== Defining the ID for id-based queries/mutatuins
As we generate a method for a query/mutation in a Spring for GraphQL controller, where the Id property is an argument, it is necessary to add the  `com.amplicode.core.graphql.annotation.GraphQLId` annotation to the method's argument. This annotation means that this argument must have the `ID` type in the GraphQL schema.


[[return-id]]
=== Defining the ID for the returned object
If a method in a Spring for GraphQL controller the returned object is marked with the `com.amplicode.core.graphql.annotation.GraphQLId` annotation, the type of the returned object (for query/mutation) should be `ID` in the schema.

[[id-type]]
=== Defining the ID for a type
The source of the GraphQL type at the time of schema generation can be:

. an Entity (JPA/Mongo/Redis)

. a DTO

If a field belonging to the DTO or Entity complies with the `Id` property condition, this field  must have the `ID` type in the GraphQL schema.

[[jpa]]
=== JPA
==== Defining the Id for JPA Entities

For JPA Entities (a class with the `javax.persistence.Entity` annotation) the `Id` property is the field annotated `javax.persistence.Id`.
//TODO